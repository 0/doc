=begin pod

=TITLE Regexes -- Pattern matching against strings

Regular expressions are a computer science concept where simple patterns
describe the format of text. Pattern matching is the process of applying
these patterns to actual text to look for matches.

The Most modern regular expression facilities are more powerful than
traditional regular expressions due to the influence of languages such as
Perl, but the short-hand term I<regex> has stuck and continues to mean
I<regular expression-like pattern matching>.

In Perl 6, although they can much more than regular languages, we
continue to call them I<regex>.

=head1 Lexical conventions

Perl 6 has special syntax for writing regexes:

    m/abc/;         # a regex that is immediately matched against $_
    rx/abc/;        # a Regex object
    /abc/;          # a Regex object

The first two can use delimiters other than the slash:

    m{abc};
    rx{abc};

Note that neither the colon C<:> nor round parentheses can be delimiters;
the colon is forbidden because it would clash with adverbs, such as
C<rx:i/abc/> (case insensitive regexes), and round parentheses would
indicate a function call instead.

Whitespace in regexes is generally ignored (except with the C<:s> or
C<:sigspace> adverb).

As in the rest of Perl 6, comments in regexes start with a hash
character C<#> and go upto the rest of the line.

=head1 Literals

The simplest case of a regex is a constant string. Matching a string
against that regex searches for that string:

    if 'properly' ~~ m/ perl / {
        say "'properly' contains 'perl'";
    }

Alphanumeric characters and the underscore C<_> are literal matches.
All other characters must either be escaped with a backslash
(for example C<\:> to a colon), or included in quotes:

    / 'two words' /     # matches 'two words' including the blank
    / "a:b"       /     # matches 'a:b' including the colon

The hash character C<#> cannot be escaped with a backslash, because
that would collide with the I<unspace> syntax. So to match a hash
character, you need to quote it:

    /'#'/               # hashes must be quoted, cannot be escaped

Strings are searched left to right for the regex, so its enough if a
substring matches the regex:

    if 'abcdef' ~~ / de / {
        say ~$/;            # de
        say $/.prematch;    # abc
        say $/.postmatch;   # f
        say $/.from;        # 3
        say $/.to;          # 5
    };

Match results are stored in the C<$/> variable, and are also returned
from the match. The result is of type L<Match>.

=head1 Wildcards and character classes

=head2 Dot to match any character

An unescaped dot C<.> in a regex matches any single character.

So these all match:

    'perl' ~~ / per . /;    # matches the whole string
    'perl' ~~ /per./;       # the same; whitespace is ignored
    'perl' ~~ / pe.l /;     # the . matches the r
    'speller' ~~ / pe.l/;   # the . matches the first l

This doesn't match:

    'perl' ~~ /. per /

because there is no character to match before C<per> in the target string.

=head2 Backslashed, predefined character classes

There are predefined character classes of the form C<\w>. Its negation is
written with an upper-case letter

=item \d and \D

C<\d> matches a single digit (Unicode property C<N>), and C<\D> matches a
single character that is not a digit.

    'ab42' ~~ /\d/ and say ~$/;     # 4
    'ab42' ~~ /\D/ and say ~$/;     # a

Note that not only the Arabic digits (commonly used in the Latin alphabet)
match C<\d>, but also digits from other scripts.

Examples for digits are

    U+0035 5 DIGIT FIVE
    U+07C2 ߂ NKO DIGIT TWO
    U+0E53 ๓ THAI DIGIT THREE
    U+1B56 ᭖ BALINESE DIGIT SIX

=item \h and \H

C<\h> matches a single horizontal whitespace character. C<\H> matches a
single character that is not a horizontal whitespace character.

Examples for horizontal whitespace characters are

    U+0020 SPACE
    U+00A0 NO-BREAK SPACE
    U+0009 CHARACTER TABULATION
    U+2001 EM QUAD

Vertical whitespaces like newline characters are explicitly excluded; those
can be matched with C<\v>, and C<\s> matches any kind of whitespace.

=item \n and \N

C<\n> matches a single, logical newline character. C<\n> is supposed to also
match a Windows CR LF codepoing pair; though it is unclear whether the magic
happens at the time that external data is read, or at regex match time. C<\N>
matches a single character that's not a logical newline.

=item \s and \S

C<\s> matches a single whitespace character. C<\S> matches a single
character that is not a whitspace.

TODO: examples

=item \t and \T

C<\t> matches a single tab/tabulation character, C<U+0009>. (Note that
exotic tabs like the C<U+000B VERTICAL TABULATION> character is not included
here). C<\T> matches a single character that is not a tab.

=item \v and \V

C<\v> matches a single vertical whitespace character. C<\V> match a single
character that is not a vertical whitspace.

Examples for vertical whitespace characters:

    U+000A LINE FEED
    U+000B VERTICAL TABULATION
    U+000C CARRIAGE RETURN
    U+0085 NEXT LINE
    U+2029 PARAGRAPH SEPARATOR

Use C<\s> to match any kind of whitespace, not just vertical whitespace

=item \w and \W

C<\w> matches a single word character, that is a letter (Unicode category L),
a digit or an underscore. C<\W> matches a single character that isn't a word
character.

Examples of word characters:

    0041 A LATIN CAPITAL LETTER A
    0031 1 DIGIT ONE
    03B4 δ GREEK SMALL LETTER DELTA
    03F3 ϳ GREEK LETTER YOT
    0409 Љ CYRILLIC CAPITAL LETTER LJE

=head2 Enumerated character classes and ranges

TODO

=head1 Quantifier

TODO

=head1 Alternation

TODO

=head1 Grouping and Capturing

TODO

=end pod
