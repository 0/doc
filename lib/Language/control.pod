=begin pod

=TITLE Control Flow

=SUBTITLE Statements used to control the flow of execution

=head2 blocks

Like many languages, Perl6 uses C<blocks> delimited by C<{> and C<}> 
to compartmentalize code.  When a block stands alone as a statement,
it will be entered immediately after the statement before it finishes,
and the statements inside it will be executed.  Otherwise, a block
simply creates a closure, which may be executed at a later time:

    say "We get here"; { say "then here." }; { say "not here"; 0; } or die;

In the above example, after running the first statement, the first
block stands alone as a second statement, so we run the statement inside
it.  The second block does not stand alone as a statement, so it instantiates
an object of type C<Block>, but does not run it.  Since any object instance
is true, the code does not die, even though that block would evaluate to 0,
were it to be executed.

Most of the flow control constructs covered below are just ways to
tell perl6 when, how, and how many times, to enter blocks like that
second block.

=head2 do

The simplest way to run a block where it cannot be a stand-alone statement
is by writing C<do> before it:

    # This dies half of the time
    do { say "Heads I win, tails I die."; Bool.pick } or die; say "I win."

Note that you need a space between the do and the block.

The whole C<do {...}> evaluates to the final value of the block.  The block
will be run when that value is needed in order to evaluate the rest of the
expression.  So:

    False and do { 42.say };

...will not say 42.  However, the block is only evaluated once each time
the expression it is contained in is evaluated:

    # This says "..1 ..2 ..3" not "..1 ...2 ....3"
    my $f = "."; say do { $f ~= "." } X~ 1,2,3;

In other words, it follows the same reification rules as everything else.

Technically, C<do> is a loop which runs exactly one iteration.

A C<do> may actually also be used on a statement (without brackets)
but this is mainly just useful for avoiding the syntactical need to
parenthesize a statement if it is the last thing in an expression:

    1, do if (1) { 2 }  ; #-> 1, 2
    1,   (if (1) { 2 }) ; #-> 1, 2
    1,    if (1) { 2 }  ; # Syntax error

=begin comment

=head2 if/elsif/else

=head2 for

=head2 gather/take

=end comment

=head2 given

The C<given> statement is Perl 6's topicalizing keyword in a similar way that
C<switch> topicalizes in languages such as C.  In other words, C<given>
sets C<$_> inside the following block.  The keywords for individual cases
are C<when> and C<default>.  The usual idiom looks like this:

    given EXPR {
        when EXPR { ... }
        when EXPR { ... }
        default { ... }
    }

The C<given> statement is often used alone:

    given EXPR { .say; .Numeric; }

This is a lot more understandable than:

    { .say; .Numeric; }(EXPR)


=head3 default and when

A block containing a C<default> statement will be left immediately
when the sub-block after the C<default> statement is left.  It is
as though the rest of the statements in the block are skipped.

    given 42 {
        "This says".say;
        $_ == 42 and ( default { "This says, too".say; 43; } );
        "This never says".say;
    }
    # The above block evaluates to 43

A C<when> statement will also do this.

In addition, C<when> statements C<smartmatch> the topic (C<$_>) against
a supplied expression such that it is possible to check against values,
regular expressions, and types when specifying a match.

    for 42, 43, "foo", 44 {
        when Int { .say }
        default  { say "Not an Int" }
    }
    #-> 42 43 Not an Int 44

In this form, the C<given>/C<when> construct acts much like a set of
C<if>/C<elsif>/C<else> statements.  Be careful with the order of the
C<when> statements.  The following code says C<"Int"> not C<42>.

    given 42 {
        when Int { say "Int" }
        when 42  { say 42 }
        default  { say "huh?" }
    }
    #-> Int

=head3 proceed and succeed

Both C<proceed> and C<succeed> are meant to be used only from inside C<when>
or C<default> blocks.

The C<proceed> statement will immediately leave the C<when> or C<default>
block, skipping the rest of the statements, and resuming after the block.
This prevents the C<when> or C<default> from exiting the outer block.

    default {
        proceed;
        "This never says".say
    }
    "This says".say;

This is most often used to enter multiple C<when> blocks.  C<proceed> will
resume matching after a successful match, like so:

    given 42 {
        when Int   { say "Int"; proceed }
        when 42    { say 42 }
        when 40..* { say "greater than 40" }
        default    { say "huh?" }
    }
    # -> Int
    # -> 42

Note that the C<when 40..*> match didn't occur.  For this to match
such cases as well, one would need a proceed in the C<when 42> block.

This is not like a C<C> C<switch> statement, because the C<proceed> does
not merely enter the directly following block, it attempts to match
the C<given> value once more, consider this code:

    given 42 {
        when Int { "Int".say; proceed }
        when 43  { 43.say }
        when 42  { 42.say }
        default  { "got change for an existential answer?".say }
    }
    #-> Int
    #-> 42

...which matches the C<Int>, skips C<43> since the value doesn't match, matches
C<42> since this is the next positive match, but doesn't enter the
C<default> block since the C<when 42> block doesn't contain a C<proceed>.

By contrast, the C<succeed> keyword shortcircuits execution and exits the
entire C<given> block at that point.  It may also take an argument to
specify a final value for the block.

    given 42 {
        when Int {
            say "Int";
            succeed "Found";
            say "never this!";
        }
        when 42 { say 42 }
        default { say "dunno?" }
    }
    #-> Int

=head2 loop

The C<loop> statement is the C-style C<for> loop in disguise:

    loop (my $i = 0; $i < 10; $i++) {
        ...
    }

As in C, the parentheses are required if you supply the 3-part spec;
however, the 3-part loop spec may be entirely omitted to write an infinite
loop.  That is,

    loop {...}

is equivalent to the C-ish idiom:

    loop (;;) {...}

=head2 repeat/while, repeat/until

Perl 5 allows one to apply a statement modifier to a C<do> block such that
C-like constructs such as

    do {
        ...
    } while $x < 10;   # allowed in Perl 5; not in Perl 6

are possible.

This is specifically disallowed in Perl 6.  Nevertheless, one can repeat a
block up to a given condition in the same way wit a C<repeat> loop:

    repeat {
        ...
    } while $x < 10;

This can also be written quite naturally with C<until>:

    repeat {
        ...
    } until $x >= 10;

=begin comment

=head2 unless

=head2 while

=head2 return

=head2 next

=head2 last

=head2 redo

=head2 goto

=end comment

=end pod

# vim: expandtab shiftwidth=4 ft=perl6
