=begin pod

=TITLE Functions

=SUBTITLE Functions and Functional Programming in Perl 6

TODO

=head1 Defining/Creating/Using Functions

TODO

=head2 X<Subroutines|declarator,sub>

To create a function, often all that's needed is to define a
subroutine using the C<sub> declarator:

    sub my-func { say "Look ma, no args!" }
    my-func;

To have the subroutine take arguments, a L<signature|Signature> goes
between the subroutine's name and its body, in parenthesis:

    =for code :allow<B L>
    sub exclaim B<($phrase)> {
        say $phrase L<~> "!!!!"
    }
    exclaim "Howdy, World";

By default, subroutines are L<lexically scoped|my>. That is
C<sub foo {...}> is the same as C<my sub foo {...}> and is only
defined in the current scope.

=begin code :allow<L>
sub escape ($str) {
    L<$_> = $str;
    # Puts a slash before non-alphanumeric characters
    L<s>:g[<-alpha-digit>] = "\\$/";
}

say escape "foo#bar?" # foo\#bar\?

{
    sub escape ($str) {
        $_ = $str;
        # Writes each non-alphanumeric character in its hexadecimal escape
        s:g|<-alpha-digit>| = "\\x[{ $/.base(16) }]";
    }

    say escape "foo#bar?" # foo\x[23]bar\x[3F]
}

# Back to original escape function
say escape "foo#bar?" # foo\#bar\?
=end code

Subroutines don't have to be named; in this case they're called anonymous.

    say sub ($a, $b) { $a ** 2 + $b ** 2 }(3, 4) # 25

But in this case, it's often desirable to use the more succint L<block|Block>
syntax.

=head2 X«Blocks and Lambdas|syntax,->»

Whenever you see something like C«{ $_ + 42 }»,
C«-> $a, $b { $a ** $b }», or C«{ $^text.indent($:spaces) }», that's
L<Block> syntax. It's used after every C<if>, C<for>, C<while>, etc.

    for 1, 2, 3, 4 -> $a, $b {
        say $a ~ $b;
    }

    12
    34

But they can also be used on their own as anonymous blocks of code.

    say { $^a ** 2 + $^b ** 2}(3, 4) # 25

For details about the syntax of blocks, see the documentation for the
L<Block> type.

=head2 Signatures

The parameters that a function accepts are described in its I<signature>.

=for code :allow<B>
sub formatB<(Str $s)> { ... }
-> B<$a, $b> { ... }

Details about the syntax and use of signatures can be found in the
L<documentation on the C<Signature> class|Signature>.

=comment capture, destructuring,

=head2 Arguments

When calling a function, positional arguments should be supplied
in the same order as the function's signature.  Named arguments
may be supplied in any order, but it is considered good form to
place named arguments after positional arguments.  Inside the
argument list of a function call, some special syntax is supported:

    f :named(35)     # A named argument (in "adverb" form.)
    f named => 35    # Also a named argument.
    f :35named       # A named argument using abbreviated adverb form
    f 'named' => 35  # Not a named argument, a Pair in a positional argument
    f |$c            # Merge the contents of Capture $c as if they were supplied

Arguments passed to a function are conceptually first collected in a
C<Capture> container.  Details about the syntax and use of these
containers can be found in the L<documentation on the C<Capture> class|Capture>.

When using named arguments, note that normal List "pair-chaining" allows
one to skip commas between named arguments.

    f :dest</tmp/foo> :src</tmp/bar> :lines(512)
    f :32x :50y :110z   # This flavor of "adverb" works, too
    f :a:b:c            # The spaces are also optional.

=head2 Multi-dispatch

Perl 6 allows you to write several routines with the same name, but different
signatures. When the routine is called by name, the runtime environment
decides which is the best match, and calls that I<candidate>.

    multi congratulate($name) {
        say "Happy birthday, $name";
    }
    multi congratulate($name, $age) {
        say "Happy {$age}th birthday, $name";
    }

    congratulate 'Larry';       # Happy birthday, Larry
    congratulate 'Bob', 45;     # Happy 45th birthday, Bob

Dispatch can happen on the number of arguments (the I<arity>), but also on the
type:

    multi as-json(Bool $d) { $d ?? 'true' !! 'false'; }
    multi as-json(Real $d) { ~$d }
    multi as-json(@d)      { sprintf '[%s]', @d.map(&as-json).join(', ') }

    say as-json([True, 42]);    # [true, 42]

=comment multi, proto, {*}, only


=head1 Functions are First-Class Objects

TODO
=comment e.g. `@list.sort :&as`, closures, lexical subs

=comment return from sub and return from block

=comment method invoke { ... }

=head2 Routines

TODO
=comment Important ones: candidates, wrap, unwrap, assuming, arity, count

=comment link to Routine documentation (?)

=head1 Defining Operators

TODO

=head2 Precedence

TODO
=comment trait-mods, tighter, equiv, etc.

=head1 Trait-mods

TODO
=comment cached, hidden_from_backtrace, pure, export, rw, DEPRECATED

=end pod
