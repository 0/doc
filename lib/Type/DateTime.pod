=begin pod

=TITLE class DateTime

=SUBTITLE A date and time object

    class DateTime does Dateish { ... }

For handling points in civil time, a C<DateTime> object stores year, month,
day, hour, minute (all L<Int|/type/Int>), second (potentially fractional) and
a time zone.

It provides methods for calculating with date and time.

C<DateTime> methods are immutable; if you are tempted to modify one, create a
modified copy instead.

Time zones are handled as L<Integers|/type/Int> in B<seconds> offset from UTC.

=head1 Methods

=head2 method new

    multi method new(Int :$year!, Int :$month, Int :$day,
                     Int :$hour, Int :$minute, :$second
                     :$timezone, :&formatter)
    multi method new(Date :$date!,
                     Int :$hour, Int :$minute, :$second
                     :$timezone=0, :&formatter)
    multi method new(Instant:D $i,  :$timezone=0, :&formatter)
    multi method new(Int:D $posix,  :$timezone=0, :&formatter)
    multi method new(Str:D $format, :$timezone=0, :&formatter)

Creates a new C<DateTime> object. One option for creating a new DatTime object
is from the components (year, month, day, hour, ...) separately. Another is to
pass a L<Date|/type/Date> object for the date component, and specify the time
component-wise. Yet another is to obtain the time from an
L<Intstant|/type/Instant>, and only suplly the time zone and formatter. Or
instead of an Instant you can supply an L<Int|/type/Int> as a UNIX timestamp,
or a C<Str|/type/Str> formatted as C<yyyy-mm-ddThh:mm::ssZ> or
C<yyyy-mm-ddThh:mm:ss+0100> (ISO 8601 timestamp notation).

An invalid input string throws and exception of type
L<X::Temporal::InvalidFormat>. If you supply a string that includes a time
zone and supply the C<timezone> named argument, and exception of type
L<X::DateTime:TimezoneClash> is thrown.

=head2 method now

    method now(:$timezone=*$TZ, &formatter) returns DateTime:D

Creates a new C<DateTime> object from the current system time, optionally with
a different timezone than the default attached.

=head2 method clone

    method clone(:$year, :$month, :$day, :$hour, :$minute, :$second,
                 :$timezone, :&formatter)

Creates a new C<DateTime> object based on the invocant, but with the given
arguments overriding the values from the invocant.

    say DateTime.new('2015-12-24T12:23:00Z').clone(hour => 0);
        # 2015-12-24T00:23:00Z

Note that this can lead to invalid dates in some circumstances:

    say DateTime.new("2012-02-29T12:34:56Z").clone(year => 2015);
        # day of 2015/2 out of range. Is: 29, should be in 1..28

=head2 method hour

    method hour(DateTime:D) returns Int:D

Returns the hour component.

    say DateTime.new('2012-02-29T12:34:56Z').hour;      # 12

=head2 method minute

    method minute(DateTime:D) returns Int:D

Returns the minute component.

    say DateTime.new('2012-02-29T12:34:56Z').minute;     # 34

=head2 method second

    method second(DateTime:D)

Returns the second component, including potentially fractional seconds.

    say DateTime.new('2012-02-29T12:34:56Z').second;     # 56

=head2 Instant

    method Instant() returns Instant:D

Returns an L<Instant|/type/Instant> object based on the invocant.

=head2 posix

    method posix($ignore-timezone = False) returns Int:D

Returns the date and time as a POSIX/UNIX timestamp.

    say DateTime.new('2015-12-24T12:23:00Z').posix;     # 1450959780

=head2 later

    method later(*%unit)

Returns a DateTime object based on the current one, but with a time delta
applied. The time delta can be passed as a named argument where the argument
name is the unit.

Allowed units are C<second>, C<seconds>, C<minute>, C<minutes>, C<hour>,
C<hours>, C<day>, C<days>, C<week>, C<weeks>, C<month>, C<months>, C<year>,
C<years>.

    say DateTime.new('2015-12-24T12:23:00Z').later(years => 2);
        # 2017-12-24T12:23:00Z

Since addition of several different time units is not commutative, only one
unit may be passed.

    my $d = DateTime.new(date => Date.new('2015-02-27'));
    say $d.later(month => 1).later(days => 2);  # 2015-03-29T00:00:00Z
    say $d.later(days => 2).later(month => 1);  # 2015-04-01T00:00:00Z

Negative offsets are allowed, though L<#method earlier> is more idiomatic for
that.

=head2 method earlier

    method earlier(*%unit)

Returns a DateTime object based on the current one, but with a time delta
towards the past applied. See L<#method later> for usage.

=head2 method truncated-to

    method truncated-to(Cool $unit)

Returns a copy of the invocant, with everything smaller than the specified
unit truncated to the smallest possible value.

    my $d = DateTime.new("2012-02-29T12:34:56Z");
    say $d.truncated-to('minute');      # 2012-02-29T12:34:00Z
    say $d.truncated-to('hour');        # 2012-02-29T12:00:00Z
    say $d.truncated-to('day');         # 2012-02-29T00:00:00Z
    say $d.truncated-to('month');       # 2012-02-01T00:00:00Z
    say $d.truncated-to('year');        # 2012-01-01T00:00:00Z

DatTimes with fractional seconds can be truncated to whole seconds with
C<.truncated-to('second')>.

=begin comment

TODO: offset, offset-in-minutes, offset-in-hours, whole-second, in-timezone,
    utc, local, Date, Str, 

=end comment

=end pod
