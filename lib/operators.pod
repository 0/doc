=begin pod

=TITLE Operators

=head1 Operator Precedence

In an expression like C<1 + 2 * 3>, the C<2 * 3> is evaluated first
because the infix C<*> has tighter B<precedence> than the C<+>.

The following table summarizes the precedence levels in Perl 6, from
tightest to loosest:

=begin table

    A  Level             Examples
    =  =====             ========
    N  Terms             42 3.14 "eek" qq["foo"] $x :!verbose @$array
    L  Method postfix    .meth .+ .? .* .() .[] .{} .<> .«» .:: .= .^ .:
    N  Autoincrement     ++ --
    R  Exponentiation    **
    L  Symbolic unary    ! + - ~ ? | || +^ ~^ ?^ ^
    L  Multiplicative    * / % %% +& +< +> ~& ~< ~> ?& div mod gcd lcm
    L  Additive          + - +| +^ ~| ~^ ?| ?^
    L  Replication       x xx
    X  Concatenation     ~
    X  Junctive and      &
    X  Junctive or       | ^
    L  Named unary       temp let
    N  Structural infix  but does <=> leg cmp .. ..^ ^.. ^..^
    C  Chaining infix    != == < <= > >= eq ne lt le gt ge ~~ === eqv !eqv
    X  Tight and         &&
    X  Tight or          || ^^ // min max
    R  Conditional       ?? !! ff fff
    R  Item assignment   = => += -= **= xx= .=
    L  Loose unary       so not
    X  Comma operator    , :
    X  List infix        Z minmax X X~ X* Xeqv ...
    R  List prefix       print push say die map substr ... [+] [*] any Z=
    X  Loose and         and andthen
    X  Loose or          or xor orelse
    X  Sequencer         <==, ==>, <<==, ==>>
    N  Terminator        ; {...}, unless, extra ), ], }

=end table

Using two C<!> symbols below generically to represent any pair of operators
that have the same precedence, the associativities specified above
for binary operators are interpreted as follows:

=begin table

    A   Assoc     Meaning of $a ! $b ! $c
    =   =====     =======================
    L   left      ($a ! $b) ! $c
    R   right     $a ! ($b ! $c)
    N   non       ILLEGAL
    C   chain     ($a ! $b) and ($b ! $c)
    X   list      infix:<!>($a; $b; $c)

=end table

For unaries this is interpreted as:


=begin table

    A   Assoc     Meaning of !$a!
    =   =====     =========================
    L   left      (!$a)!
    R   right     !($a!)
    N   non       ILLEGAL

=end table

In the operator descriptions below, a default associativity of I<left>
is assumed.

=head1 Operator classification

Operators can occur in several positions relative to a term:

=begin table

    +term           prefix
    term1 + term2   infix
    term++          postfix
    (term)          circumfix
    term1[term2]    postcircumfix

=end table

Each operator is also available as a routine; postcircumfix operators as
methods, all others as subroutines. The name of the routine is formed of
the operator category, then a colon, and a list quote construct with the
symbol(s) that make up the operator:

    infix:<+>(1, 2)                 # same as 1 + 2
    circumfix:«( )»('a', 'b', 'c')  # same as ('a', 'b', 'c')

=head1 Method Postfix

=head2 postfix .

The operator for calling one method, C<$invocant.method>.

Technically this is not an operator, but syntax special-cased in the compiler.

=head2 postfix .?

Potential method calls. C<$invocant.?method> calls method C<method> on
C<$invocant> if it has a method of such name. Otherwise it returns L<Nil>.

Technically this is not an operator, but syntax special-cased in the compiler.

=head2 postfix .+

C<$invocant.+method> calls all methods called C<method> from C<$invocant>,
and returns a L<Parcel> of the results. Dies if no such method was found.

Technically this is not an operator, but syntax special-cased in the compiler.

=head2 postfix .*

C<$invocant.+method> calls all methods called C<method> from C<$invocant>,
and returns a L<Parcel> of the results. If no such method was found, an empty
L<Parcel> is returned.

Technically this is not an operator, but syntax special-cased in the compiler.

# TODO: .= .^ .:: .() .[] .{} .<>

=head1 Autoincrement Precedence

=head2 prefix ++

    multi sub prefix:<++>($x is rw) is assoc<none>

Increments its argument by one, and returns the incremented value.

    my $x = 3;
    say ++$x;       # 4
    say $x;         # 4

It works by calling the L<succ> method (for I<successor>) on its argument,
which gives custom types the freedom to implement their own incrementation
semantics.

=head2 prefix --

    multi sub prefix:<-->($x is rw) is assoc<none>

Decrements its argument by one, and returns the decremented value.

    my $x = 3;
    say --$x;       # 2
    say $x;         # 2

It works by calling the L<pred> method (for I<predecessor>) on its argument,
which gives custom types the freedom to implement their own decrementation
semantics.


=head2 postfix ++

    multi sub postfix:<++>($x is rw) is assoc<none>

Increments its argument by one, and returns the unincremented value.

    my $x = 3;
    say $++x;       # 3
    say $x;         # 4

It works by calling the L<succ> method (for I<successor>) on its argument,
which gives custom types the freedom to implement their own incrementation
semantics.

Note that this does not necessarily return its argument. For example for
undefined values, it returns 0:

    my $x;
    say $x++;       # 0
    say $x;         # 1

=head2 postfix --

    multi sub postfix:<-->($x is rw) is assoc<none>

Decrements its argument by one, and returns the undecremented value.

    my $x = 3;
    say $x--;       # 3
    say $x;         # 2

It works by calling the L<pred> method (for I<predecessor>) on its argument,
which gives custom types the freedom to implement their own decrementation
semantics.

Note that this does not necessarily return its argument. For example for
undefined values, it returns 0:

    my $x;
    say $x--;       # 0
    say $x;         # -1

=head1 Exponentation Precedence

=head2 infix **

    multi sub infix:<**>(Any, Any) returns Numeric:D is assoc<right>

The exponentiation operator coerces both arguments to L<Numeric>
and calculates the left-hand-side raised to the power of the right-hand side.

If the right-hand side is a non-negative integer and the left-hand side
is an arbitrary precision type (L<Int>, L<FatRat>), then the calculation
is carried out without loss of precision.

=head1 Symbolic Unary Precedence

=head2 prefix ?

    multi sub prefix:<?>(Mu) returns Bool:D

Boolean context operator.

Coerces the argument to L<Bool> by calling the C<Bool> method on it.
Note that this collapses L<Junction>s.

=head2 prefix !

    multi sub prefix:<!>(Mu) returns Bool:D

Negated boolean context operator.

Coerces the argument to L<Bool> by calling the C<Bool> method on it,
and returns the negation of the result.
Note that this collapses L<Junction>s.

=head2 prefix +

    multi sub prefix:<+>(Any) returns Numeric:D

Numeric context operator.

Coerces the argument to L<Numeric> by calling the C<Numeric> method on it.

=head2 prefix -

    multi sub prefix:<->(Any) returns Numeric:D

Negative numeric context operator.

Coerces the argument to L<Numeric> by calling the C<Numeric> method on it,
and then negates the result.

=head2 prefix ~

    multi sub prefix:<->(Any) returns Str:D

String context operator.

Coerces the argument to L<Str> by calling the C<Str> method on it.

=head2 prefix |

Flattens objects of type L<Capture>, L<Enum>, L<Pair>, L<List>, L<Parcel>,
L<EnumMap> and L<Hash> into an argument list.

(In Rakudo, this is implemented not as a proper operator but as a special
case in the compiler, which means it only works in argument lists, not in
arbitrary code).

=head2 prefix +^

    multi sub prefix:<+^>(Any) returns Int:D

Integer bitwise negation.

Coerces the argument to L<Int> and does a bitwise negation on the result,
assuming L<two's complement|https://en.wikipedia.org/wiki/Two%27s_complement>.

=head2 prefix ?^

    multi sub prefix:<?^>(Mu) returns Bool:D

Boolean bitwise negation.

Coerces the argument to L<Bool> and then does a bit flip, which makes it the
same as C<< prefix:<!> >>.

=head2 prefix ^

    multi sub prefix:<^>(Any) returns Range:D

I<upto> operator.

Coerces the argument to C<Numeric>, and generates a range from 0 up to (but
excluding) the argument.

    say ^5;         # 0..^5
    for ^5 { }      # 5 iterations

=head1 Multiplicative Precedence

=head2 infix *

    multi sub infix:<*>(Any, Any) returns Numeric:D

Coerces both arguments to L<Numeric> and multiplies them. The result
is of the wider type. See L<Numeric> for details.

=head2 infix /

    multi sub infix:</>(Any, Any) returns Numeric:D

Coerces both argument to L<Numeric> and divides the left through the right
number. Division of L<Int> values returns L<Rat>, otherwise the "wider type"
rule described in L<Numeric> holds.

=head2 infix div

    multi sub infix:<div>(Int:D, Int:D) returns Int:D

Integer division. Rounds down.

=head2 infix %

    multi sub infix:<%>($x, $y) return Numeric:D

Modulo operator. Coerces to L<Numeric> first.

Generally the following identity holds:

    $x % $y == $x - floor($x / $y) * $y

=head2 infix %%

    multi sub infix:<%%>($a, $b) returns Bool:D

Divisibility operator. Returns C<True> if L<$a %  $b == 0>.

=head2 infix mod

    multi sub infix:<mod>(Int:D $a, Int:D $b) returns Int:D

Integer modulo operator. Returns the remainder of an integer modulo operation.

=head2 infix +&

    multi sub infix:<+&>($a, $b) returns Int:D

Numeric bitwise I<AND>. Coerces both arguments to L<Int> and does a bitwise
L<AND> operation assuming two's complement.

=head2 infix +<

    multi sub infix:<< +< >>($a, $b) returns Int:D

Integer bit shift to the left.

=head2 infix +>

    multi sub infix:<< +> >>($a, $b) returns Int:D

Integer bit shift to the right.

=head2 infix gcd

    multi sub infix:<gcd>($a, $b) returns Int:D

Coerces both arguments to L<Int> and returns the greatest common denominator.

=head2 infix lcm

    multi sub infix:<lcm>($a, $b) returns Int:D

Coerces both arguments to L<Int> and returns the least common multiple,
that is the smallest integer that is smallest integer that is evenly
divisible by both arguments.

=head1 Additive Precedence

=head2 infix +

    multi sub infix:<+>($a, $b) returns Numeric:D

Coerces both arguments to L<Numeric> and adds them.

=head2 infix -

    multi sub infix:<->($a, $b) returns Numeric:D

Coerces both arguments to L<Numeric> and subtracts the second from the
first.

=head2 infix +|

    multi sub infix:<+|>($a, $b) returns Int:D

Coerces both arguments to L<Int> and does a bitwise I<OR> (inclusive OR)
operation.

=head2 infix +^

    multi sub infix:<+^>($a, $b) returns Int:D

Coerces both arguments to L<Int> and does a bitwise I<XOR> (exclusive OR)
operation.

=head2 infix ?|

    multi sub infix:<?|>($a, $b) returns Bool:D

Coerces both arguments to L<Bool> and does a logical I<OR> (inclusive OR)
operation.

=head1 Replication Precedence

=head2 infix x

    proto sub infix:<x>(Any, Any) returns Str:D
    multi sub infix:<x>(Any, Any)
    multi sub infix:<x>(Str:D, Int:D)

Coerces C<$a> to L<Str> and C<$b> to L<Int> and repeats the string C<$b>
times. Return the empty string if C<< $b <= 0 >>.

    say 'ab' x 3;       # ababab
    say 42 x 3;         # 424242

=head2 infix xx

    multi sub infix:<xx>($a, $b) returns List:D

Returns a list of C<$a> repeated and evaluated C<$b> times (C<$b> is coerced
to L<Int>). If C<< $b <= 0 >>, the empty list is returned.

The left-hand side is evaluated for each repetition, so

    [1, 2] xx 5

returns five distinct arrays (but with the same content each time), and

    rand xx 3

returns three pseudo random numbers that are determined independently.

The right-hand side can be C<*>, in which case a lazy, infinite list
is returned.

=head1 Concatenation

=head2 infix ~

    proto sub infix:<~>(Any, Any) returns Str:D
    multi sub infix:<~>(Any,   Any)
    multi sub infix:<~>(Str:D, Str:D)

Coerces both arguments to L<Str> and concatenates them.

    say 'ab' ~ 'c';     # abc

=head1 Junctive AND (all) Precedence

=head2 infix &

    multi sub infix:<&>($a, $b) returns Junction:D is assoc<list>

Creates an I<all> L<Junction> from its arguments. See L<Junction> for more
details.

=head1 Junctive OR (any) Precedence

=head2 infix |

    multi sub infix:<|>($a, $b) returns Junction:D is assoc<list>

Creates an I<any> L<Junction> from its arguments. See L<Junction> for more
details.

=head2 infix ^

    multi sub infix:<^>($a, $b) returns Junction:D is assoc<list>

Creates a I<one> L<Junction> from its arguments. See L<Junction> for more
details.

=head1 Named Unary Precedence

=head2 prefix temp

    sub prefix:<temp>(Mu $a is rw)

"temporizes" the variable passed as the argument, which means it is reset
to its old value on scope exit. (This is similar to the
L<local|http://perldoc.perl.org/functions/local.html> operator in Perl 5,
except that C<temp> does not reset the value).

=head2 prefix let

    sub prefix:<let>(Mu $a is rw)

Hypothetical reset: if the current scope is exited either through an exception
or C<fail()>, the old value is restored.

=head1 Nonchaining Binary Precedence

=head2 infix does

    sub infix:<does>(Mu $obj, Mu $role) is assoc<none>

Mixes C<$role> into C<$obj> at run time. Requires C<$obj> to be mutable.

C<$role> doesn't need to a be a role, it can be something that knows how
to act like a role, for example enum values.

=head2 infix but

    sub infix:<but>(Mu $obj, Mu $role) is assoc<none>

Creates a copy of C<$obj> with C<$role> mixed in. Since C<$obj> is not
modified, C<but> can be used to created immutable values with mixins.

C<$role> doesn't need to a be a role, it can be something that knows how
to act like a role, for example enum values.

=head2 infix cmp

    proto sub infix:<cmp>(Any, Any) returns Order:D is assoc<none>
    multi sub infix:<cmp>(Any,       Any)
    multi sub infix:<cmp>(Real:D,    Real:D)
    multi sub infix:<cmp>(Str:D,     Str:D)
    multi sub infix:<cmp>(Enum:D,    Enum:D)
    multi sub infix:<cmp>(Version:D, Version:D)

Generic, "smart" three-way comparator.

Compares strings with string semantics, numbers
with number semantics, L<Pair> objects first by key and then by value etc.

if C<$a eqv $b>, then C<$a cmp $b> always returns C<Order::Same>.

    say (a => 3) cmp (a => 4);      # Increase
    say 4        cmp 4.0;           # Same
    say 'b'      cmp 'a';           # Decrease

=head2 infix leg

    proto sub infix:<leg>($a, $b) returns Order:D is assoc<none>
    multi sub infix:<leg>(Any,   Any)
    multi sub infix:<leg>(Str:D, Str:D)

String three-way comparator.

Coerces both arguments to L<Str>, and then does a lexicographic comparison.

=head2 infix <=>

    multi sub infix:«<=>»($a, $b) returns Order:D is assoc<none>

Numeric three-way comparator.

Coerces both arguments to L<Real>, and then does a numeric comparison.

=head2 infix ..

    multi sub infix:<..>($a, $b) returns Range:D is assoc<none>

Constructs a L<Range> from the arguments.

=head2 infix ..^

    multi sub infix:<..^>($a, $b) returns Range:D is assoc<none>

Constructs a L<Range> from the arguments, excluding the end point.

=head2 infix ^..

    multi sub infix:<^..>($a, $b) returns Range:D is assoc<none>

Constructs a L<Range> from the arguments, excluding the start point.


=head2 infix ^..^

    multi sub infix:<^..^>($a, $b) returns Range:D is assoc<none>

Constructs a L<Range> from the arguments, excluding both start and end point.

=head1 Chaining Binary Precedence

=head2 infix ==

    proto sub infix:<==>($, $) returns Bool:D is assoc:<chain>
    multi sub infix:<==>(Any, Any)
    multi sub infix:<==>(Int:D, Int:D)
    multi sub infix:<==>(Num:D, Num:D)
    multi sub infix:<==>(Rational:D, Rational:D)
    multi sub infix:<==>(Real:D, Real:D)
    multi sub infix:<==>(Complex:D, Complex:D)
    multi sub infix:<==>(Numeric:D, Numeric:D)

Coerces both arguments to L<Numeric> if necessary, and returns C<True>
if they are equal.

=head2 infix !=

    proto sub infix:<!=>(Mu, Mu) returns Bool:D is assoc<chain>

Coerces both arguments to L<Numeric>, and returns C<True> if they are
distinct.

=head2 infix <

    proto sub infix:«<»(Any, Any) returns Boold:D is assoc<chain>
    multi sub infix:«<»(Int:D, Int:D)
    multi sub infix:«<»(Num:D, Num:D)
    multi sub infix:«<»(Real:D, Real:D)

Coerces both arguments to L<Real>, and returns C<True> if the first argument
is smaller than the second.

=head2 infix <=

    proto sub infix:«<=»(Any, Any) returns Boold:D is assoc<chain>
    multi sub infix:«<=»(Int:D, Int:D)
    multi sub infix:«<=»(Num:D, Num:D)
    multi sub infix:«<=»(Real:D, Real:D)

Coerces both arguments to L<Real>, and returns C<True> if the first argument
is smaller than or equal to the second.


=head2 infix >

    proto sub infix:«>»(Any, Any) returns Boold:D is assoc<chain>
    multi sub infix:«>»(Int:D, Int:D)
    multi sub infix:«>»(Num:D, Num:D)
    multi sub infix:«>»(Real:D, Real:D)

Coerces both arguments to L<Real>, and returns C<True> if the first argument
is larger than the second.

=head2 infix >=

    proto sub infix:«>=»(Any, Any) returns Boold:D is assoc<chain>
    multi sub infix:«>=»(Int:D, Int:D)
    multi sub infix:«>=»(Num:D, Num:D)
    multi sub infix:«>=»(Real:D, Real:D)

Coerces both arguments to L<Real>, and returns C<True> if the first argument
is larger than or equal to the second.

=end pod
